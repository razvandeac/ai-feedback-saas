create extension if not exists "citext" with schema "public" version '1.6';

create type "public"."org_role" as enum ('owner', 'admin', 'member', 'viewer');

create table "public"."events" (
    "id" bigint generated by default as identity not null,
    "project_id" uuid not null,
    "widget_id" uuid,
    "type" text not null,
    "payload" jsonb not null,
    "user_agent" text,
    "ip" inet,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."events" enable row level security;

create table "public"."feedback" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "project_id" uuid not null,
    "widget_id" uuid,
    "rating" integer,
    "comment" text,
    "metadata" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."feedback" enable row level security;

create table "public"."invites" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "org_id" uuid not null,
    "email" citext not null,
    "role" org_role not null default 'member'::org_role,
    "token" text not null,
    "invited_by" uuid,
    "accepted_at" timestamp with time zone,
    "expires_at" timestamp with time zone not null default (now() + '14 days'::interval),
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."invites" enable row level security;

create table "public"."memberships" (
    "org_id" uuid not null,
    "user_id" uuid not null,
    "role" org_role not null default 'member'::org_role,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."memberships" enable row level security;

create table "public"."org_invites" (
    "id" uuid not null default gen_random_uuid(),
    "org_id" uuid not null,
    "email" citext not null,
    "role" text not null,
    "invited_by" uuid not null,
    "token" uuid not null default gen_random_uuid(),
    "status" text not null default 'pending'::text,
    "created_at" timestamp with time zone not null default now(),
    "accepted_at" timestamp with time zone
);


alter table "public"."org_invites" enable row level security;

create table "public"."organizations" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "name" text not null,
    "slug" text,
    "created_by" uuid not null,
    "created_at" timestamp with time zone not null default now()
);


create table "public"."platform_admins" (
    "email" text not null
);


create table "public"."platform_feedback" (
    "id" uuid not null default gen_random_uuid(),
    "source" text,
    "rating" integer,
    "comment" text,
    "email" text,
    "metadata" jsonb,
    "status" text default 'new'::text,
    "created_at" timestamp with time zone default now()
);


alter table "public"."platform_feedback" enable row level security;

create table "public"."profiles" (
    "user_id" uuid not null,
    "full_name" text,
    "avatar_url" text,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."profiles" enable row level security;

create table "public"."projects" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "org_id" uuid not null,
    "name" text not null,
    "key" text not null,
    "created_at" timestamp with time zone not null default now(),
    "allowed_origins" text[],
    "require_project_origins" boolean not null default false
);


alter table "public"."projects" enable row level security;

create table "public"."widget_config" (
    "project_id" uuid not null,
    "settings" jsonb not null default '{}'::jsonb,
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."widget_config" enable row level security;

create table "public"."widgets" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "project_id" uuid not null,
    "name" text not null,
    "kind" text not null default 'inline'::text,
    "config" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."widgets" enable row level security;

CREATE UNIQUE INDEX events_pkey ON public.events USING btree (id);

CREATE INDEX events_project_created_idx ON public.events USING btree (project_id, created_at DESC);

CREATE UNIQUE INDEX feedback_pkey ON public.feedback USING btree (id);

CREATE INDEX feedback_project_created_idx ON public.feedback USING btree (project_id, created_at DESC);

CREATE INDEX idx_events_project_created ON public.events USING btree (project_id, created_at DESC);

CREATE INDEX idx_events_project_type_created ON public.events USING btree (project_id, type, created_at DESC);

CREATE INDEX idx_events_type ON public.events USING btree (type);

CREATE INDEX idx_feedback_project_created ON public.feedback USING btree (project_id, created_at DESC);

CREATE INDEX idx_feedback_rating ON public.feedback USING btree (rating);

CREATE INDEX idx_org_invites_email ON public.org_invites USING btree (email);

CREATE INDEX idx_org_invites_org ON public.org_invites USING btree (org_id);

CREATE INDEX idx_projects_key ON public.projects USING btree (key);

CREATE INDEX idx_projects_org ON public.projects USING btree (org_id);

CREATE UNIQUE INDEX invites_pkey ON public.invites USING btree (id);

CREATE UNIQUE INDEX invites_token_key ON public.invites USING btree (token);

CREATE UNIQUE INDEX memberships_pkey ON public.memberships USING btree (org_id, user_id);

CREATE UNIQUE INDEX org_invites_pkey ON public.org_invites USING btree (id);

CREATE UNIQUE INDEX organizations_pkey ON public.organizations USING btree (id);

CREATE UNIQUE INDEX organizations_slug_idx ON public.organizations USING btree (slug);

CREATE UNIQUE INDEX organizations_slug_key ON public.organizations USING btree (slug);

CREATE UNIQUE INDEX platform_admins_pkey ON public.platform_admins USING btree (email);

CREATE UNIQUE INDEX platform_feedback_pkey ON public.platform_feedback USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (user_id);

CREATE UNIQUE INDEX projects_org_id_key_key ON public.projects USING btree (org_id, key);

CREATE UNIQUE INDEX projects_pkey ON public.projects USING btree (id);

CREATE UNIQUE INDEX uq_org_invites_token ON public.org_invites USING btree (token);

CREATE UNIQUE INDEX uq_projects_key ON public.projects USING btree (key);

CREATE UNIQUE INDEX widget_config_pkey ON public.widget_config USING btree (project_id);

CREATE UNIQUE INDEX widgets_pkey ON public.widgets USING btree (id);

alter table "public"."events" add constraint "events_pkey" PRIMARY KEY using index "events_pkey";

alter table "public"."feedback" add constraint "feedback_pkey" PRIMARY KEY using index "feedback_pkey";

alter table "public"."invites" add constraint "invites_pkey" PRIMARY KEY using index "invites_pkey";

alter table "public"."memberships" add constraint "memberships_pkey" PRIMARY KEY using index "memberships_pkey";

alter table "public"."org_invites" add constraint "org_invites_pkey" PRIMARY KEY using index "org_invites_pkey";

alter table "public"."organizations" add constraint "organizations_pkey" PRIMARY KEY using index "organizations_pkey";

alter table "public"."platform_admins" add constraint "platform_admins_pkey" PRIMARY KEY using index "platform_admins_pkey";

alter table "public"."platform_feedback" add constraint "platform_feedback_pkey" PRIMARY KEY using index "platform_feedback_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."projects" add constraint "projects_pkey" PRIMARY KEY using index "projects_pkey";

alter table "public"."widget_config" add constraint "widget_config_pkey" PRIMARY KEY using index "widget_config_pkey";

alter table "public"."widgets" add constraint "widgets_pkey" PRIMARY KEY using index "widgets_pkey";

alter table "public"."events" add constraint "events_project_id_fkey" FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE not valid;

alter table "public"."events" validate constraint "events_project_id_fkey";

alter table "public"."events" add constraint "events_widget_id_fkey" FOREIGN KEY (widget_id) REFERENCES widgets(id) ON DELETE SET NULL not valid;

alter table "public"."events" validate constraint "events_widget_id_fkey";

alter table "public"."feedback" add constraint "feedback_project_id_fkey" FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE not valid;

alter table "public"."feedback" validate constraint "feedback_project_id_fkey";

alter table "public"."feedback" add constraint "feedback_widget_id_fkey" FOREIGN KEY (widget_id) REFERENCES widgets(id) ON DELETE SET NULL not valid;

alter table "public"."feedback" validate constraint "feedback_widget_id_fkey";

alter table "public"."invites" add constraint "invites_invited_by_fkey" FOREIGN KEY (invited_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."invites" validate constraint "invites_invited_by_fkey";

alter table "public"."invites" add constraint "invites_org_id_fkey" FOREIGN KEY (org_id) REFERENCES organizations(id) ON DELETE CASCADE not valid;

alter table "public"."invites" validate constraint "invites_org_id_fkey";

alter table "public"."invites" add constraint "invites_token_key" UNIQUE using index "invites_token_key";

alter table "public"."memberships" add constraint "memberships_org_id_fkey" FOREIGN KEY (org_id) REFERENCES organizations(id) ON DELETE CASCADE not valid;

alter table "public"."memberships" validate constraint "memberships_org_id_fkey";

alter table "public"."memberships" add constraint "memberships_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."memberships" validate constraint "memberships_user_id_fkey";

alter table "public"."org_invites" add constraint "org_invites_org_id_fkey" FOREIGN KEY (org_id) REFERENCES organizations(id) ON DELETE CASCADE not valid;

alter table "public"."org_invites" validate constraint "org_invites_org_id_fkey";

alter table "public"."org_invites" add constraint "org_invites_role_check" CHECK ((role = ANY (ARRAY['owner'::text, 'admin'::text, 'member'::text]))) not valid;

alter table "public"."org_invites" validate constraint "org_invites_role_check";

alter table "public"."org_invites" add constraint "org_invites_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'revoked'::text, 'expired'::text]))) not valid;

alter table "public"."org_invites" validate constraint "org_invites_status_check";

alter table "public"."organizations" add constraint "organizations_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) ON DELETE RESTRICT not valid;

alter table "public"."organizations" validate constraint "organizations_created_by_fkey";

alter table "public"."organizations" add constraint "organizations_slug_key" UNIQUE using index "organizations_slug_key";

alter table "public"."profiles" add constraint "profiles_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_user_id_fkey";

alter table "public"."projects" add constraint "projects_allowed_origins_nonempty" CHECK (((allowed_origins IS NULL) OR (array_position(allowed_origins, ''::text) IS NULL))) not valid;

alter table "public"."projects" validate constraint "projects_allowed_origins_nonempty";

alter table "public"."projects" add constraint "projects_org_id_fkey" FOREIGN KEY (org_id) REFERENCES organizations(id) ON DELETE CASCADE not valid;

alter table "public"."projects" validate constraint "projects_org_id_fkey";

alter table "public"."projects" add constraint "projects_org_id_key_key" UNIQUE using index "projects_org_id_key_key";

alter table "public"."projects" add constraint "uq_projects_key" UNIQUE using index "uq_projects_key";

alter table "public"."widget_config" add constraint "widget_config_project_id_fkey" FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE not valid;

alter table "public"."widget_config" validate constraint "widget_config_project_id_fkey";

alter table "public"."widgets" add constraint "widgets_project_id_fkey" FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE not valid;

alter table "public"."widgets" validate constraint "widgets_project_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_users_lite(ids uuid[])
 RETURNS TABLE(id uuid, email text, full_name text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    u.id::uuid,
    u.email::text,
    COALESCE((u.raw_user_meta_data->>'full_name')::text, '')::text as full_name
  FROM auth.users u
  WHERE u.id = ANY(ids);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  insert into public.profiles(user_id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url')
  on conflict (user_id) do nothing;
  return new;
end; $function$
;

CREATE OR REPLACE FUNCTION public.handle_org_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  insert into public.memberships(org_id, user_id, role)
  values (new.id, new.created_by, 'owner')
  on conflict do nothing;
  return new;
end; $function$
;

CREATE OR REPLACE FUNCTION public.is_org_admin(_org uuid, _user uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  select exists (
    select 1 from public.memberships m
    where m.org_id = _org and m.user_id = _user and m.role in ('owner','admin')
  );
$function$
;

CREATE OR REPLACE FUNCTION public.is_org_member(_org uuid, _user uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  select exists (select 1 from public.memberships m where m.org_id = _org and m.user_id = _user);
$function$
;

CREATE OR REPLACE FUNCTION public.is_org_member(check_org uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  select exists(
    select 1 from public.memberships m
    where m.org_id = check_org and m.user_id = auth.uid()
  );
$function$
;

CREATE OR REPLACE FUNCTION public.normalize_origins(arr text[])
 RETURNS text[]
 LANGUAGE sql
 IMMUTABLE STRICT
AS $function$
  select case
    when arr is null then null
    else array(
      select x from (
        select nullif(btrim(elem), '') as x
        from unnest(arr) as t(elem)
      ) s
      where x is not null
    )
  end
$function$
;

CREATE OR REPLACE FUNCTION public.tg_projects_normalize_origins()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.allowed_origins := public.normalize_origins(new.allowed_origins);
  return new;
end $function$
;

create policy "events_member"
on "public"."events"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM projects p
  WHERE ((p.id = events.project_id) AND is_org_member(p.org_id)))));


create policy "events_write_edge"
on "public"."events"
as permissive
for insert
to public
with check (true);


create policy "feedback_member"
on "public"."feedback"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM projects p
  WHERE ((p.id = feedback.project_id) AND is_org_member(p.org_id)))));


create policy "feedback_write_member"
on "public"."feedback"
as permissive
for insert
to public
with check ((EXISTS ( SELECT 1
   FROM projects p
  WHERE ((p.id = feedback.project_id) AND is_org_member(p.org_id)))));


create policy "inv_select_member"
on "public"."invites"
as permissive
for select
to public
using (is_org_member(org_id));


create policy "inv_write_admin"
on "public"."invites"
as permissive
for all
to public
using ((EXISTS ( SELECT 1
   FROM memberships m
  WHERE ((m.org_id = invites.org_id) AND (m.user_id = auth.uid()) AND (m.role = ANY (ARRAY['owner'::org_role, 'admin'::org_role]))))))
with check ((EXISTS ( SELECT 1
   FROM memberships m
  WHERE ((m.org_id = invites.org_id) AND (m.user_id = auth.uid()) AND (m.role = ANY (ARRAY['owner'::org_role, 'admin'::org_role]))))));


create policy "mem_delete_admin"
on "public"."memberships"
as permissive
for delete
to public
using ((EXISTS ( SELECT 1
   FROM memberships m
  WHERE ((m.org_id = memberships.org_id) AND (m.user_id = auth.uid()) AND (m.role = ANY (ARRAY['owner'::org_role, 'admin'::org_role]))))));


create policy "mem_insert_admin"
on "public"."memberships"
as permissive
for insert
to authenticated
with check (true);


create policy "mem_select_member"
on "public"."memberships"
as permissive
for select
to authenticated
using (true);


create policy "Admins can update invites for their orgs"
on "public"."org_invites"
as permissive
for update
to authenticated
using ((EXISTS ( SELECT 1
   FROM memberships
  WHERE ((memberships.org_id = org_invites.org_id) AND (memberships.user_id = auth.uid()) AND (memberships.role = ANY (ARRAY['owner'::org_role, 'admin'::org_role]))))));


create policy "Users can create invites for their orgs"
on "public"."org_invites"
as permissive
for insert
to authenticated
with check ((EXISTS ( SELECT 1
   FROM memberships
  WHERE ((memberships.org_id = org_invites.org_id) AND (memberships.user_id = auth.uid()) AND (memberships.role = ANY (ARRAY['owner'::org_role, 'admin'::org_role]))))));


create policy "Users can view invites for their orgs"
on "public"."org_invites"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM memberships
  WHERE ((memberships.org_id = org_invites.org_id) AND (memberships.user_id = auth.uid())))));


create policy "invites delete by admins"
on "public"."org_invites"
as permissive
for delete
to authenticated
using (is_org_admin(org_id, auth.uid()));


create policy "invites insert by admins"
on "public"."org_invites"
as permissive
for insert
to authenticated
with check (is_org_admin(org_id, auth.uid()));


create policy "invites select by admins or invitee"
on "public"."org_invites"
as permissive
for select
to authenticated
using ((is_org_admin(org_id, auth.uid()) OR (EXISTS ( SELECT 1
   FROM auth.users u
  WHERE ((u.id = auth.uid()) AND ((u.email)::text = (org_invites.email)::text))))));


create policy "invites update by admins or invitee"
on "public"."org_invites"
as permissive
for update
to authenticated
using ((is_org_admin(org_id, auth.uid()) OR (EXISTS ( SELECT 1
   FROM auth.users u
  WHERE ((u.id = auth.uid()) AND ((u.email)::text = (org_invites.email)::text))))))
with check (true);


create policy "orgs_admin_update"
on "public"."organizations"
as permissive
for update
to public
using ((EXISTS ( SELECT 1
   FROM memberships m
  WHERE ((m.org_id = organizations.id) AND (m.user_id = auth.uid()) AND (m.role = ANY (ARRAY['owner'::org_role, 'admin'::org_role]))))));


create policy "orgs_insert_auth"
on "public"."organizations"
as permissive
for insert
to authenticated
with check ((auth.uid() = created_by));


create policy "orgs_member_select"
on "public"."organizations"
as permissive
for select
to public
using (is_org_member(id));


create policy "allow insert from public endpoint"
on "public"."platform_feedback"
as permissive
for insert
to public
with check (true);


create policy "allow select for admins only"
on "public"."platform_feedback"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM platform_admins a
  WHERE (a.email = (auth.jwt() ->> 'email'::text)))));


create policy "profiles_self_insert"
on "public"."profiles"
as permissive
for insert
to public
with check ((user_id = auth.uid()));


create policy "profiles_self_select"
on "public"."profiles"
as permissive
for select
to public
using ((user_id = auth.uid()));


create policy "profiles_self_update"
on "public"."profiles"
as permissive
for update
to public
using ((user_id = auth.uid()));


create policy "projects delete by admins"
on "public"."projects"
as permissive
for delete
to authenticated
using (is_org_admin(org_id, auth.uid()));


create policy "projects insert by admins"
on "public"."projects"
as permissive
for insert
to authenticated
with check (is_org_admin(org_id, auth.uid()));


create policy "projects select by org members"
on "public"."projects"
as permissive
for select
to authenticated
using (is_org_member(org_id, auth.uid()));


create policy "projects update by admins"
on "public"."projects"
as permissive
for update
to authenticated
using (is_org_admin(org_id, auth.uid()))
with check (is_org_admin(org_id, auth.uid()));


create policy "projects_member"
on "public"."projects"
as permissive
for all
to public
using (is_org_member(org_id))
with check (is_org_member(org_id));


create policy "widget_config insertable by org admins"
on "public"."widget_config"
as permissive
for insert
to public
with check ((EXISTS ( SELECT 1
   FROM (projects p
     JOIN memberships m ON ((m.org_id = p.org_id)))
  WHERE ((p.id = widget_config.project_id) AND (m.user_id = auth.uid()) AND (m.role = ANY (ARRAY['owner'::org_role, 'admin'::org_role]))))));


create policy "widget_config readable by org members"
on "public"."widget_config"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM (projects p
     JOIN memberships m ON ((m.org_id = p.org_id)))
  WHERE ((p.id = widget_config.project_id) AND (m.user_id = auth.uid())))));


create policy "widget_config writable by org admins"
on "public"."widget_config"
as permissive
for update
to public
using ((EXISTS ( SELECT 1
   FROM (projects p
     JOIN memberships m ON ((m.org_id = p.org_id)))
  WHERE ((p.id = widget_config.project_id) AND (m.user_id = auth.uid()) AND (m.role = ANY (ARRAY['owner'::org_role, 'admin'::org_role]))))))
with check (true);


create policy "widgets_member"
on "public"."widgets"
as permissive
for all
to public
using ((EXISTS ( SELECT 1
   FROM projects p
  WHERE ((p.id = widgets.project_id) AND is_org_member(p.org_id)))))
with check ((EXISTS ( SELECT 1
   FROM projects p
  WHERE ((p.id = widgets.project_id) AND is_org_member(p.org_id)))));


CREATE TRIGGER on_org_created AFTER INSERT ON public.organizations FOR EACH ROW EXECUTE FUNCTION handle_org_insert();

CREATE TRIGGER trg_projects_normalize_origins BEFORE INSERT OR UPDATE OF allowed_origins ON public.projects FOR EACH ROW EXECUTE FUNCTION tg_projects_normalize_origins();


CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION handle_new_user();


